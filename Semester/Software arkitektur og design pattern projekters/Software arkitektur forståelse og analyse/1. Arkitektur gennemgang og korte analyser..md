# ARKITEKTURKORT ‚Äî Oversigt over arkitekturtyper.


# üß± **1. Klassisk Layered Architecture (3-Tier / N-Tier)**

## **Opbygning**

- UI (pr√¶sentation)
- Business / Service Layer
- Data / Repository / Database Access

## **God til**

- sm√• til mellemstore systemer
- simple dom√¶ner
- hurtig udvikling
- struktureret adskillelse mellem UI og database
- let at forst√• (lav l√¶ringskurve)

## **Ulemper**

- Service Layer bliver ofte stort og rodet og med en masse services.
- dom√¶neregler spredes ud
- EF og teknologier siver op i dom√¶nelaget
- use cases er ikke isolerede
- afh√¶ngigheder g√•r _nedad_, ikke _indad_
- sv√¶rt at udvide med nye moduler (fx AI)

## **Sammenspil med projektet**

I begyndelsen overvejede jeg denne arkitektur fint, fordi projektet virkede til at have et mindre dom√¶ne med simplere regler samt en begr√¶nset m√¶ngde features i f√∏lge vores analyser.
Men da det virker til at AI-delen kr√¶ver lidt tilkobling udefra og da der iforhold til features er flere end f√∏rst antaget, s√• virker det ikke hel optimalt.

---

# üü¶ **2. Hexagonal Architectur

## **Opbygning**

- **Core Domain** i midten
- **Ports** (interfaces) omkring
- **Adapters** (implementeringer) i ydre lag
- Data, UI, API‚Äôer er ‚Äúplugins‚Äù

## **God til**

- st√¶rk isolation af dom√¶net
- let at udskifte teknologier
- testbarhed
- eksterne moduler s√•som AI eller API-klienter
- l√∏s kobling

## **Ulemper**

- kr√¶ver meget disciplin
- For tungt til vores mindre projekter og kan ende med overengineering.

## **Sammenspil med projektet**


Da jeg kiggede p√• Hexagonal Architecture, kunne jeg godt se nogle id√©er der gav mening for projektet. Is√¶r tanken om, at alt ‚Äúudenfor‚Äù dom√¶net skal behandles som adaptere, som man kan skifte ud uden at r√∏re kerne-logikken.

Det passer fint til:

- vores AI-del, som k√∏rer i Python
- databaseadgangen
- mails/notifikationer

Hexagonal er fedt, men det er ogs√• ret ‚Äútungt‚Äù i den fulde form.  
Kravene til struktur, opdeling og dokumentation bliver hurtigt mere end vi reelt har brug for ‚Äî is√¶r fordi vi _ikke_ bygger microservices, og fordi vores team ikke har mulighed for at have meget samspil og analyse af den komplekse implementering det vil f√∏re til.

S√• min konklusion blev:

Hexagonal gav nogle gode id√©er**, is√¶r omkring AI og eksterne ting som adaptere ‚Äî  
> men det ville v√¶re overkill at bruge som vores prim√¶re arkitektur.

I et lille projekt som vores, hvor vi gerne vil holde tingene fleksible uden at overdesigne alt,  



# üü© **3. Clean Architecture**

## **Opbygning**

- **Domain (Entities, Events, Value Objects)**
- **Application (Use cases, Commands, Queries, Interfaces)**
- **Infrastructure (Repos, EF Core, Email, API‚Äôer, Identity)**
- **UI (Web / Blazor)**

Afh√¶ngigheder m√• KUN g√• indad mod Domain.

## **God til**

- komplekse dom√¶ner
- DDD-Principper
- klare use cases
- h√∏j testbarhed
- AI og eksterne systemer som infrastruktur
- Strukturering af kodeprojektet.

## **Ulemper**

- Flere nye tiltag der skal l√¶res.
- kr√¶ver disciplin
- st√∏rre mappestruktur

## **Sammenspil med projektet**

Clean Architecture virker til at passe godt til problemerne i vores projekt:

- domain forbliver rent
- AI blev en ekstern enhed.
- application use cases isolerer forretningslogik

---

# üüß **4. Vertical Slice Architecture**


## **Opbygning**

Hver feature (slice) indeholder:

- komponenter
- handlers
- modeller
- validering
- routes

## **God til**

- store UI-lag (Blazor / ASP.NET)
- undg√• gigantiske service-lag
- klare feature-moduler
- hurtigere udvikling
- h√∏j sammenh√¶ng (cohesion)

## **Ulemper**

- kr√¶ver struktur
- matcher bedst sammen med Clean / CQRS

## **Sammenspil med projektet**

Her er det en fin nem m√•de at opdele features og arbejde p√• tv√¶rs af hinanden i teamet, da man kan arbejde isoleret med egne features og emner i forhold til vertical slice principperne selv ved minimalt samarbejde og evaluering i teamet.



# üü• **5. Microservices Architecture.

jeg analyserede kort microservices for at se, om det passede.

## **God til**

- store organisationer
- mange teams eller store teams
- ekstrem skalering af enkelte komponenter

## **Ulemper**

- ekstrem kompleksitet
- kr√¶ver DevOps, Kubernetes, distributed logging, tracing
- hver service har sin egen database
- slet ikke egnet til et lille projekt

## **Sammenspil med projektet**

- AI-delen kunne v√¶re en microservice
- men resten af systemet ville blive over-engineered

---

# üü© **6. Modul√¶r Monolith (analyse af denne arkitekturform)**

## **Opbygning (generelt)**

En modul√¶r monolith er stadig **√©t samlet system**, men internt opdelt i moduler eller ‚Äúmini-dom√¶ner‚Äù, ofte styret af:

- Clean Architecture eller andre lagdelingsmodeller
- Vertical Slice eller feature-baseret struktur i UI
- Dom√¶neomr√•der opdelt som moduler eller bounded contexts
- En f√¶lles database eller delt infrastruktur
- Mulighed for eksterne moduler som AI, email, logging m.v.

## **Hvad en modul√¶r monolith generelt er god til**

- H√∏j cohesion**: hvert modul har sine egne regler og logik
- Lav coupling**: moduler er adskilt af interfaces, domain events eller boundaries
- Skalering uden microservice-kompleksitet**
- God udvikleroplevelse**: √©t projekt, men med klare gr√¶nser
- Mulighed for senere opsplitning** (hvis man vokser)


## **Ulemper**

- Kr√¶ver disciplin**, s√• modulerne ikke begynder at ‚Äúl√¶kke‚Äù sammen
- St√∏rre intern struktur**, som kan virke tungt p√• et lille team
- Kan blive for meget**, hvis projektet reelt er lille og ikke vokser
- Klar afgr√¶nsning af dom√¶ner** kan kr√¶ve en del designarbejde


Det er derfor en arkitektur, der giver rigtig god mening, hvis projektet _vokser_ ‚Äî men kan f√∏les overdrevet, hvis det er meget lille.


## **Sammenspil med projektet (generelt, ikke beslutning)**

Under analysen af vores projekt har modul√¶r monolith vist sig som en mulighed, der:

- giver plads til, at dom√¶net kan udvikle sig i flere retninger
- passer godt til feature-baseret UI og vertical slice
- underst√∏tter rene lag og domain-fokuseret design
- ikke kr√¶ver drift eller kompleksitet som microservices
- tillader ekstern teknologi (fx AI) at ligge som eget modul
- bevarer fordelen ved √©t samlet system (deploy, debugging, performance)
