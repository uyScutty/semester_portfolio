

Efter at have etableret arkitekturen (Clean Architecture + Vertical Slice + Modulær Monolith), var næste skridt at skabe en solid domænemodel. Arkitekturen giver rammen — men **DDD (Domain-Driven Design)** giver _indholdet_ i domænet.

I dette indlæg forklarer vi:

- hvorfor DDD blev nødvendigt i vores projekt
    
- hvordan DDD er koblet til vores arkitektur
    
- hvilke patterns vi bruger i domænet
    
- hvordan disse patterns påvirker projektets struktur og logik
    
- hvordan de forbereder os til næste del af læringen: design patterns
    

---

# 1) Hvorfor vi havde brug for DDD i projektet

DDD blev ikke valgt fordi “det er moderne”, men fordi:  
**vores domæne var for komplekst til simple modeller.**

Projektet havde:

- content med regler og moderation
    
- medlemskaber (premium, owner, normal)
    
- reviews og opsummeringer
    
- domænehændelser
    
- forskellige brugertyper
    
- flere bounded contexts
    
- AI-genererede anbefalinger og analyser
    
- valideringsregler, workflows og tilstande
    

Dette er præcis den type system, hvor DDD giver værdi.

---

# 2) Hvordan DDD understøtter vores arkitektur

DDD passer perfekt ovenpå Clean Architecture.

## ✔ Domain-laget får rene modeller

Entities og Value Objects uden EF Core eller AI-logik.

## ✔ Application-laget bliver orkestrator

Use case handlers styrer workflows gennem Commands og Queries.

## ✔ Infrastructure bliver teknologisk adapter

Database, AI, Identity, Email og Logging er plugins.

## ✔ Vertical Slice forbinder UI til use cases

Hver slice aktiverer en handler, som interagerer med domænet.

DDD beskriver **hvad der foregår i domænet**, Clean Architecture beskriver **hvor det ligger**, og Vertical Slice beskriver **hvordan det bruges**.

---

# 3) DDD-begreber brugt i projektet

Her gennemgår vi de konkrete patterns, du rent faktisk bruger i dit projekt — og som læreren forventer, du kan forklare.

---

# ⭐ **A) Entities — ting med identitet**

Eksempler fra projektet:

- **Content** (post/artikel)
    
- **Review**
    
- **Membership**
    
- **User**
    

Karakteristika:

- har ID
    
- ændrer tilstand
    
- har regler
    
- kan trigge domain events
    

**I projektet:**  
Entities ligger i _Domain_ og indeholder AL logik der hører til objektets kerne.

---

# ⭐ **B) Value Objects — værdier der repræsenterer kvalitet, ikke identitet**

Eksempler:

- **Title**
    
- **ContentBody**
    
- **MembershipType**
    
- **EmailAddress**
    

Karakteristika:

- immutables
    
- sammenlignes på værdi
    
- valideres i konstruktøren
    

**I projektet:**  
Value Objects blev vigtige for at sikre datakvalitet og forretningsregler tæt på modellen.

---

# ⭐ **C) Domain Services — logik der ikke hører til en enkelt entity**

Eksempler:

- Beregning af medlemskab tilstand
    
- Moderationsstrategi for content
    
- Aggregation af data på tværs af entities
    

Domain services ligger i **Domain**, men de _orkestrerer_ regler mellem flere modeller.

---

# ⭐ **D) Aggregates — grupper af entities der hænger sammen**

Eksempler:

- Content + Reviews kan være separate aggregates
    
- Membership kan være sin egen aggregate
    

Regel:

> “Kun aggregate root må eksponeres til omverdenen.”

Dette styrer dataintegritet og reducerer coupling.

---

# ⭐ **E) Domain Events — hændelser udløst af domænet**

Brugt aktivt i projektet:

- **PostPublishedEvent**
    
- **MembershipActivatedEvent**
    
- **ReviewCreatedEvent**
    

Fordele:

- løs kobling mellem domæner
    
- Application-layer håndterer sideeffekter
    
- Infrastructure udfører tekniske ting (fx email, AI analyse)
    

Dette passer perfekt til Clean Architecture’s afhængighedsregler.

---

# ⭐ **F) Repositories (DDD-versionen)**

I DDD er et repository:

> “En samling af aggregates som du henter og gemmer.”

Vi bruger:

- IContentRepository
    
- IUserRepository
    
- IMembershipRepository
    
- IReviewRepository
    

Alle som **interfaces i Application-laget**  
og **implementeret i Infrastructure** (EF Core).

Dette giver:

- lav coupling
    
- teknologisk udskiftelighed
    
- klar ansvarsfordeling
    

---

# ⭐ **G) Bounded Contexts — de naturlige domæneopdelinger**

I vores projekt fandt vi disse bounded contexts:

- **Content**
    
- **Membership**
    
- **Review**
    
- **Notification**
    
- **Chat/AI**
    

Hver context har:

- egne modeller
    
- egne events
    
- egne regler
    
- egne use cases
    
- egne vertical slices
    

Dette er fundamentet for modulær monolith.

---

# 4) Hvordan DDD patterns understøtter projektets arkitektur

Når vi ser DDD sammen med Clean Architecture og Vertical Slice, fungerer de sådan:

### ✔ DDD giver domænet form

→ Entities, Value Objects, Aggregates, Events

### ✔ Clean Architecture beskytter domænet

→ Domain er rent, Application orkestrerer

### ✔ Vertical Slice styrer brugen i UI og Use Cases

→ hver feature kobler direkte til en handler i Application

### ✔ Modulær Monolith holder domænerne samlet men adskilt

→ bounded contexts er moduler, ikke microservices

---

# 5) Hvordan DDD patterns gør koden bedre (for dig og i praksis)

### ⭐ Koden bliver nemmere at læse

(Entity-logik samlet, ingen spaghetti)

### ⭐ Domænet afspejler virkeligheden

(membership, content, premium, moderation)

### ⭐ Regler bor samme sted som data

(ikke i services og controllers)

### ⭐ Domænet er framework-uafhængigt

(giver testbarhed og mulighed for fremtidige ændringer)

### ⭐ Sideeffekter håndteres korrekt

(domain event → application handler → infra service)

### ⭐ Perfect match til design patterns

(strategy, factory, observer vs domain events)

---

# 6) Hvordan dette leder naturligt videre til design patterns

DDD bruger allerede patterns — og du bruger dem i projektet.

Det giver en glidende overgang til næste indlæg:

- **Strategy Pattern** i moderation, membership, AI flows
    
- **Factory Pattern** i content creation og domænebygning
    
- **Observer vs Domain Events** (dit projekt bruger Domain Events)
    
- **Repository Pattern** (DDD-versionen)
    
- **CQRS** via Commands/Queries i vertical slices
    
- **Specification Pattern** (valgfrit, men passer godt til domæneregler)
    

DDD er derfor broen mellem:

✔ arkitekturen (Clean + Vertical + Modulær Monolith)  
✔ og patterns-delen, som kommer i næste fase af læringsforløbet.

---

# ⭐ **Konklusion**

DDD blev ikke et teoretisk lag i projektet — det blev den måde, vi strukturerede domænet på:

- Entities og Value Objects beskytter data og regler
    
- Aggregates og domain boundaries styrer kompleksitet
    
- Domain Events gør domænet reaktivt og fleksibelt
    
- Repositories abstraherer persistence
    
- Domain services håndterer regler på tværs
    
- Bounded contexts giver modulopdeling
    

Sammen med Clean Architecture og Vertical Slice skaber DDD en robust, skalerbar og forståelig kodebase, der kan bære både AI, domænekoblinger og fremtidig vækst.